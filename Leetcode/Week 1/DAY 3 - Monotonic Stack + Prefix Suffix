Before we start,
1. Normal stack: can push/pop anything, no ordering guarentee
Monotonic stack = a stack that stays in one order the whole time.
Monotonic increasing stack: numbers in the stack go up (bottom → top).
Monotonic decreasing stack: numbers in the stack go down.

You scan left → right.
When a new number would “break the order”, you pop until the order is fixed.
Why it’s useful: it helps you quickly find the next bigger or next smaller thing.



LC496 (warm-up: next greater w/ stack + map)
Actually super easy
Design: monotonic stack

When: problem revolves around the stack, use the stack to store key(the val) -> next largest number in a HashMap
Core Loop: we create HashMap and then a stack (with Deque<Integer> stack = new ArrayDeque<>();
- we loop through string 2, for each string, we check if stack is empty, if its not empty, we check if the number we currently have is bigger than the number in the stack
- if its bigger, then we store it in the map (stack.pop(), current)
- once that loop is done, we have 1 more loop for the remaining elements in the stack
- while stack is not empty, we loop through it and then assign map.put(stack.pop(), -1)
- once this is done, our map is ready to be used to compute the result
- loop through s1
- for the s1[i] -> we just need to do result[i] = map.get(s1[i]) since the map key which is that s1[i] stores the value (next biggest number)
- done
Bugs: just some syntax from typing too quick

LC739 Daily temperatures
Design: Monotonic stack
simple design-> super eays, we just need a stack that stores new int[] {theIndex, temperature}
- we store index because the temperatures are not unique
- we dont need hashmap, since we store index, we know the location right away ( Different from LC496 because it needs a map due to output being per value in nums1 and answer is built from nums2
- This is just 1 array -> new int[] temperatures

CoreLoop: we loop it, and then check if currentTemperature > stackpeek()[1]
- if its bigger, we just store it into the result -> result[index, daysDiff] where
- int[] temp = stack.pop()
- index = temp[0];
- daysDifferent = currentIndex - storedIndex so currentIndex - temp[1]
= result[index] = currentIndex (or i if ur looping for(int i = 0)) - temp[0]

and then after that we add the current to stack -> stack.push(i, temperatures[i])
and return result; //because its 0 by default, so we dont need another while loop to loop it to put 0 to the existing stack stuff


LC503 (Next Greater Element II)
- so... we store index ->
index that have yet to find the next biggest and store it into the stack.
Every loop we have our currentvalue, and then use it to compare it with the stack values
we visit the index and see if that fits if yes remove index since thats solved thats it
- LIFO order is what makes the algorithm correctly match each


LC901 (span = previous greater)
- basically its the same as finding the next greatest because all before the next greatest, if its bigger than that, the the ones before are all valid
- so all I need is store the span
- if my current > the stack, then I can pop the stack off and update it with my current bigger price, new span
- because if the next price is smaller than stack, its going to be just span = 1 anyway and that will be pushed in as well
- easy and done

LC84 -> largest rectangle histogram
- we have a stack that store the indices of the bar...
- if stack is [1, 4, 7], it means height[1] <= height[4] <= height[7]
- we loop heights.length, we make it <= heights.length so that when it hits heights.length, we make sure theres no pending rectangle waiting to finish
- but we dont access heights array so it doesnt go out of index, just compute the pending rectangle if theres any
- for the while loop, we check if the stack height is > current, if its higher, means we cannot include that higher, so we pop and update it with the current
- mainly because the currentHeight is too short to be included in the rectangle whose height is the topheight,
- so if its shorter, then we pop the bar out of stack, compute the area then discard it.
- and then the current height stays the same and may cause more pops...

-> We are not starting from mid and searching both sides., current index is right boundary
--> so we extend if the left is bigger than the current -> this way its like current Height * how many times we can go to the left
--> if its smaller than the current, then it wont be a valid rectangle
1, 5, 6
Current height = 2

6 > 2 → pop (finish height 6)

5 > 2 → pop (finish height 5)

1 > 2 → ❌ stop (1 can still extend)


LC907 (range contribution w/ next smaller)



LC42 (trap w/ stack version)

LC155 (quick cooldown)

LC503 - Need to redo

LC901 (span = previous greater) - need to redo

LC84 - redo
